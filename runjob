<?php

/////////////////////////////////////////////////////////////////////////////////////////
// For development. Comment these out for production
/////////////////////////////////////////////////////////////////////////////////////////
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);
ini_set('log_errors', 1);
ini_set('error_log', '/var/www/drencrom-test/job_errors.log');
/////////////////////////////////////////////////////////////////////////////////////////

$privateDirectory = __DIR__;
require $privateDirectory . '/vendor/autoload.php';


use Dren\App;
use Dren\FileLockableDataStore;
use Dren\Job;
use Dren\LockableDataStore;
use Dren\Logger;
use Dren\Model\DAOs\JobDAO;


App::initCli($privateDirectory);
$mutex = null;
if(App::get()->getConfig()->jobs_lockable_datastore_type === 'file')
    $mutex = new FileLockableDataStore(App::get()->getPrivateDir() . '/storage/locks/jobs');
$jobDao = new JobDAO();
$jobId = null;
$executionId = null;

function verifyClassName(string $name) : bool|string
{
    $className = '';
    if(class_exists("App\\Jobs\\" . $name))
        $className = "App\\Jobs\\" . $name;
    elseif(class_exists("Dren\\Jobs\\" . $name))
        $className = "Dren\\Jobs\\" . $name;

    if($className === '')
    {
        $message = "Provided classname: " . $name . " does not exist";
        Logger::write($message);
        echo $message . "\n";
        return false;
    }

    return $className;
}

function verifyArgumentCount(int $argCount) : bool
{
    if($argCount % 2 == 0)
    {
        $message = "When calling multiple jobs with runjob command, total number of arguments must be odd";
        Logger::write($message);
        echo $message . "\n";
        return false;
    }

    return true;
}

function handleJobException(Exception $e) : void
{
    global $mutex;
    global $executionId;
    global $jobDao;

    $errorMessage = $e->getMessage() . ":" . $e->getTraceAsString();

    if($executionId !== null)
        $jobDao->updateJobExecution($executionId, date('Y-m-d H:i:s'), 'FAILED','FAILED', $errorMessage);
    else
        Logger::write($errorMessage);

    $mutex->closeLock();
    $mutex->deleteUnsafe();
}

/**
 * @throws Exception
 */
function run(Job $j) : bool
{
    global $jobId;
    global $mutex;
    global $jobDao;
    global $executionId;

    if(!$j->preCondition())
    {
        $mutex->closeLock();
        $mutex->deleteUnsafe();

        return false;
    }

    $executionId = $jobDao->createJobExecution(getmypid(), $jobId, date('Y-m-d H:i:s'), 'RUNNING');
    $mutex->overwriteContents($executionId);

    $j->logic();

    $jobDao->updateJobExecution($executionId, date('Y-m-d H:i:s'), 'COMPLETED', 'SUCCESS', $j->getSuccessMessage());

    $mutex->closeLock();
    $mutex->deleteUnsafe();

    return true;
}

/**
 * @throws Exception
 */
function runConcurrent(Job $j) : bool
{
    global $jobId;
    global $mutex;

    $jobId = $j->generateFilenameFromObject();

    // append unique value to end of jobId since multiple can run at once
    $kindaUniqueValue = time() . random_int(0, 9999);
    $jobId = $jobId . '_' . $kindaUniqueValue;

    $mutex->openLock($jobId);

    return run($j);
}

/**
 * @throws Exception
 */
function runSequential(Job $j) : bool
{
    global $jobId;
    global $mutex;
    global $jobDao;

    $jobId = $j->generateFilenameFromObject();

    if($mutex->idExists($jobId))
    {
        if(!$mutex->tryToLock($jobId))
        {
            $message = "Job attempted to run while another instance of job was currently running: " . $jobId;
            Logger::write($message);
            echo $message . "\n";
            return false; // unable to get lock so another process is doing something with this job, get out
        }

        $prevId = $mutex->getContents();
        if($prevId != '')
            $jobDao->updateJobExecution((int)$mutex->getContents(), date('Y-m-d H:i:s'),'FAILED', 'INTERRUPTED', null);
    }
    else
    {
        $mutex->openLock($jobId);
    }

    return run($j);
}


if($argc > 1)
{
    // Just a single call to a single job, without passing data
    if($argc === 2)
    {
        $className = verifyClassName($argv[1]);
        if($className === false)
            exit(1);

        try
        {
            $job = new $className();

            if($job->isConcurrent())
                runConcurrent($job);
            else
                runSequential($job);

            exit(0);
        }
        catch(Exception $e)
        {
            handleJobException($e);
            exit(1);
        }
    }

    // If we've made it here, this is either a call to a single job passing a string of data, or a call to multiple jobs
    // each must contain a string of data, if no data necessary, an empty string must be provided
    verifyArgumentCount($argc);

    // TODO: really have to think about how this is going to play out, I don't think we had it correct the first time
    // either because we didn't really think about what happens whenever a preCondition fails
    // UPDATE: if a preCondition fails, we return false indicating that the job did not execute it's logic() method successfully
    $executionLog = [];
    for ($i = 1; $i < $argc; $i += 2)
    {
        $className = verifyClassName($argv[1]);
        if($className === false)
            exit(1);

        $classData = $argv[$i+1];

        if(!(new $className(json_decode($classData)))->run())
        {
            $executionLog[] = ["job" => $className, "data" => $classData, "status" => 'failed'];
            throw new Exception("Execution of aggregate job failed: " . json_encode($executionLog));
        }

        $executionLog[] = ["job" => $className, "data" => $classData, "status" => 'success'];
    }
}
